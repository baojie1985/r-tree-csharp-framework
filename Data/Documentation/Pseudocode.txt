*** Flash R-Tree ***

Point to Ponder:  Are updates to *data objects* handled by an insertion/deletion?  (I'm thinking yes.)
If so, maybe we should immediately convert to the relevant insert/delete instruction.
If not, how do we explain the terrible clustering that we will eventually have in the R-tree?
Note that internal nodes still need an update operation.

Major Additions
1) Reservation Buffer Implementation
2) Node Translation Table Implementation

- Reservation Table Object
  * Array of buffer objects with configurable maximum length 

- Buffer Object
  * Record Entry ID
  * Record Entry Spatial Location
  * Record Entry Child Pointer (internal node) OR Record Entry Data Pointer (leaf node)
  * Operation (Insert, Update, Delete)
  * Containing Node ID
  * Parent Node Pointer

- Node Translation Table (NTT) Object
  * Array of Node Traversal Lists (NTL) with variable maximum array length
    - Entry for each node in tree

- Node Translation List (NTL) Object
  * Node ID
  * Linked list of disk page ID's that contain entries for node with given ID
    - Configurable maximum length of linked list

- Modified Node Load Algorithm
  (Use whenever a node needs to be retrieved from cache/disk)
  LoadNode (Node N)
  Look up the NTL for N in the NTT using N.ID
  For each page in the NTL
    For each index unit in the page
      If the index unit refers to N
        Modify the in-memory construction of N by performing the specified operation
  For each buffer object in the reservation table
    If the buffer object refers to N
      Modify the in-memory construction of N by performing the specified operation
  Return final modified in-memory node 
  

- Modified Insertion Algorithm
   Identify tree location for insert as usual (store traversal path for recursive update)
   B = { Record Entry information provided by insert call
         Operation = Insert
         Containing Node, Parent Node determined by tree traversal
       }
   Call AddToBuffer with object B


- Modified Deletion Algorithm
   Identify tree location for deletion as usual (store traversal path for recursive update)
   B = { Record Entry information provided by deletion call
         Operation = Deletion
         Containing Node, Parent Node determined by tree traversal
       }
   Call AddToBuffer with object B
     
     
- Modified Update Algorithm
(* see comment above; maybe translate into insert and delete for data nodes.  Internal nodes still need update option! *)
   Identify tree location for update as usual (store traversal path for recursive update)
   B = { Record Entry information provided by update call
         Operation = Update
         Containing Node, Parent Node determined by tree traversal
       }
   Call AddToBuffer with object B


- AddToBuffer (BufferObject B)
   If reservation buffer full
     Remove any complementary operations (insert/remove same object)
     For each Node N referenced in reservation buffer
       If changes will cause node to overflow
         (*need to insert new internal node N' using BufferObject C*)
         C = {  Record Entry information provided by inspecting N
	        Operation = Insert
	        Containing Node is Parent of N
	        Parent Node determined by stored tree traversal
	     }
         Add C to items to be processed
         For each record moved from N
           B' = { Record Entry information provided by inspecting N
                  Operation = Delete
                  Containing Node is N
                  Parent Node determined by stored tree traversal
                }
           Add B' to items to be processed
           
           B'' = { Record Entry information provided by inspecting N
	   	   Operation = Insert
	   	   Containing Node is N'
	   	   Parent Node same as N
	         }
           Add B'' to items to be processed
           (*results will funnel back to reservation table so check any new nodes for overflow/underflow as well*)
       If changes will cause node to underflow
         (*need to delete internal node N using BufferObject C*)
         C = {  Record Entry information provided by inspecting N
	        Operation = Delete
	        Containing Node is Parent of N
	        Parent Node determined by stored tree traversal
	     }
         Add C to items to be processed
         For each record in N         
           B' = { Record Entry information provided by inspecting N
	   	   Operation = Insert
	   	   Containing Node is found using tree traversal
	   	   Parent Node is found using tree traversal
	         }
           Add B' to items to be processed
           (*results will funnel back to reservation table so check any new nodes for overflow/underflow as well*)
       Else
         While Parent Node of N != NULL
           B' = { Record Entry information provided by buffer objects
                  Operation = Update
                  Containing Node is Parent Node of N
                  Parent Node determined by stored tree traversal
                }
           Add B' to items to be processed
           (*results will funnel back to reservation table so check any new nodes for overflow/underflow as well*)
         B = B'
       
     Convert BufferObjects to IndexUnits (essentially the same thing only on disk)
     Cluster IndexUnits with same containing node into same page
     Add remaining IndexUnits to free space in arbitrary page
     For each newly formed page
       Call UpdateNTT(Page)
       Write Page to disk
     Clear reservation buffer
   Add B to reservation buffer
     

- UpdateNTT (Page P)
   For each Node N referenced in P
     Add P to the NTL for the ID associated with N
     If NTL length exceeds maximum allowed
       For each page in the NTL
         Read all entries associated with N.ID
       Write entries out in consecutive pages
       Update NTL for N.ID to reference new pages

 

*** Flash R-Tree Ext ***

Reservation Buffer Spatial Clustering



*** R#-Tree Ext ***

